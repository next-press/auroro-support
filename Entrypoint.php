<?php

namespace Auroro\Support;

use Auroro\Support\Concerns\HasHooks;
use Auroro\Contracts\Bridge\RequestResolver;
use Auroro\Contracts\Http\BypassableResponse;
use Illuminate\Contracts\Foundation\Application;
use Illuminate\Contracts\Http\Kernel;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Pipeline;
use Symfony\Component\HttpFoundation\Response as HttpFoundationResponse;

class Entrypoint
{
    use HasHooks;

    /**
     * The request resolver callback.
     *
     * @var callable|RequestResolver
     */
    protected $requestResolver;

    protected $responseMutator = [];

    protected Kernel $kernel;

    protected Request $request;

    protected HttpFoundationResponse $response;

    public function __construct(
        public Application $app
    ) {
    }

    public function withRequestResolver(RequestResolver|callable $requestResolver): static
    {
        $this->requestResolver = $requestResolver;

        return $this;
    }

    public function pipeResponseThrough($callback): static
    {
        $this->responseMutator[] = $callback;

        return $this;
    }

    protected function resolveRequest(): Request
    {
        if (is_null($this->requestResolver)) {
            return Request::capture();
        }

        if (is_callable($this->requestResolver)) {
            return call_user_func($this->requestResolver);
        }

        return $this->app->call($this->requestResolver, [], 'resolve');
    }

    public function handle(): static
    {
        $this->kernel = $this->app->make(Kernel::class);

        $this->response = $this->kernel->handle(
            $this->request = $this->resolveRequest()
        );

        $this->response = Pipeline::send($this->response)
            ->through($this->responseMutator)
            ->thenReturn();

        return $this;
    }

    /**
     * Delegate the response to the WordPress layer.
     *
     * It uses the shutdown hook to terminate the application.
     * It also hooks into the send_headers hook to send the headers generated by the application.
     */
    public function bypass(): static
    {
        $this->sendHeaders();
        $this->on('shutdown', [$this, 'terminate']);

        require app('wp.template');

        return $this;
    }

    public function send(): static
    {
        if (is_a($this->response, BypassableResponse::class)) {
            $this->bypass();

            return $this;
        }

        $this->response->send();

        return $this;
    }

    public function getStatusCode(): int
    {
        return $this->response->getStatusCode();
    }

    public function getResponse(): HttpFoundationResponse
    {
        return $this->response;
    }

    public function getContent(): string
    {
        return $this->response->getContent();
    }

    public function sendContent(): static
    {
        $this->response->sendContent();

        return $this;
    }

    public function sendHeaders(): static
    {
        $this->response->sendHeaders();

        return $this;
    }

    public function terminate(): static
    {
        $this->kernel->terminate($this->request, $this->response);

        return $this;
    }
}
